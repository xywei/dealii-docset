<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FETools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FETools Namespace Reference<div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceFETools_1_1Compositing"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html">Compositing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFETools_1_1FEFactory.html">FEFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFETools_1_1FEFactoryBase.html">FEFactoryBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4945a239d321d126dfccce60a73a4e67"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4945a239d321d126dfccce60a73a4e67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a4945a239d321d126dfccce60a73a4e67">compute_component_wise</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; unsigned int &gt; &amp;renumbering, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;start_indices)</td></tr>
<tr class="separator:a4945a239d321d126dfccce60a73a4e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f8f27696c0adadc316996b7281f096"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad7f8f27696c0adadc316996b7281f096"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ad7f8f27696c0adadc316996b7281f096">compute_block_renumbering</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;renumbering, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;block_data, bool return_start_indices=true)</td></tr>
<tr class="separator:ad7f8f27696c0adadc316996b7281f096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42118e6f1c76038d4ac41ebf140a4b62"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a42118e6f1c76038d4ac41ebf140a4b62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a42118e6f1c76038d4ac41ebf140a4b62">hierarchic_to_lexicographic_numbering</a> (unsigned int degree, std::vector&lt; unsigned int &gt; &amp;h2l)</td></tr>
<tr class="separator:a42118e6f1c76038d4ac41ebf140a4b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336ef517d9517ab78bbaea2499cfe801"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a336ef517d9517ab78bbaea2499cfe801"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a336ef517d9517ab78bbaea2499cfe801">hierarchic_to_lexicographic_numbering</a> (const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;fe_data)</td></tr>
<tr class="separator:a336ef517d9517ab78bbaea2499cfe801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db6ab2ac1c2318f07fc020756cf76b9"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a1db6ab2ac1c2318f07fc020756cf76b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a1db6ab2ac1c2318f07fc020756cf76b9">lexicographic_to_hierarchic_numbering</a> (const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;fe_data, std::vector&lt; unsigned int &gt; &amp;l2h)</td></tr>
<tr class="separator:a1db6ab2ac1c2318f07fc020756cf76b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd88ec1f100c5b1cf1add3669d5d696"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:aafd88ec1f100c5b1cf1add3669d5d696"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aafd88ec1f100c5b1cf1add3669d5d696">lexicographic_to_hierarchic_numbering</a> (const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;fe_data)</td></tr>
<tr class="separator:aafd88ec1f100c5b1cf1add3669d5d696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f65ecfe844cd5221a57290fa411d07"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:aa8f65ecfe844cd5221a57290fa411d07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aa8f65ecfe844cd5221a57290fa411d07">get_fe_by_name</a> (const std::string &amp;name)</td></tr>
<tr class="separator:aa8f65ecfe844cd5221a57290fa411d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad274d541ca470e7295b4485eb5b1083"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:aad274d541ca470e7295b4485eb5b1083"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, dim &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aad274d541ca470e7295b4485eb5b1083">get_fe_from_name</a> (const std::string &amp;name) 1</td></tr>
<tr class="separator:aad274d541ca470e7295b4485eb5b1083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a006641198ca5641c5c8ae20b741b4b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5a006641198ca5641c5c8ae20b741b4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a5a006641198ca5641c5c8ae20b741b4b">add_fe_name</a> (const std::string &amp;name, const <a class="el" href="classFETools_1_1FEFactoryBase.html">FEFactoryBase</a>&lt; dim, spacedim &gt; *factory)</td></tr>
<tr class="separator:a5a006641198ca5641c5c8ae20b741b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29863aa7dd0b071bb6794c7780b59ff8"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga29863aa7dd0b071bb6794c7780b59ff8">ExcInvalidFEName</a> (std::string arg1)</td></tr>
<tr class="separator:ga29863aa7dd0b071bb6794c7780b59ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d7f25c13e56c14ae3b2cc69ec01bc5a"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0d7f25c13e56c14ae3b2cc69ec01bc5a">ExcInvalidFEDimension</a> (char arg1, int arg2)</td></tr>
<tr class="separator:ga0d7f25c13e56c14ae3b2cc69ec01bc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1564c6a41140a82b31758ab7788e166a"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1564c6a41140a82b31758ab7788e166a">ExcInvalidFE</a> ()</td></tr>
<tr class="separator:ga1564c6a41140a82b31758ab7788e166a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab80c21572aa32fc4f1968c8d39753f65"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab80c21572aa32fc4f1968c8d39753f65">ExcFENotPrimitive</a> ()</td></tr>
<tr class="separator:gab80c21572aa32fc4f1968c8d39753f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01adbbdc5056b89fc67a493ad3af9fc7"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga01adbbdc5056b89fc67a493ad3af9fc7">ExcTriangulationMismatch</a> ()</td></tr>
<tr class="separator:ga01adbbdc5056b89fc67a493ad3af9fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdbc2dd19680de9ac68a79cbaa1ab52a"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacdbc2dd19680de9ac68a79cbaa1ab52a">ExcHangingNodesNotAllowed</a> (int arg1)</td></tr>
<tr class="separator:gacdbc2dd19680de9ac68a79cbaa1ab52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aa747e8b7b04063843fb90805d481a1"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0aa747e8b7b04063843fb90805d481a1">ExcGridNotRefinedAtLeastOnce</a> ()</td></tr>
<tr class="separator:ga0aa747e8b7b04063843fb90805d481a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a43c92ec3cacaf605a2d08199b655f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga19a43c92ec3cacaf605a2d08199b655f">ExcMatrixDimensionMismatch</a> (int arg1, int arg2, int arg3, int arg4)</td></tr>
<tr class="separator:ga19a43c92ec3cacaf605a2d08199b655f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga628e5c6c0c85ee833402bf1177a8d73d"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga628e5c6c0c85ee833402bf1177a8d73d">ExcLeastSquaresError</a> (double arg1)</td></tr>
<tr class="separator:ga628e5c6c0c85ee833402bf1177a8d73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga056d78564708ec422d408c360503c061"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga056d78564708ec422d408c360503c061">ExcNotGreaterThan</a> (int arg1, int arg2)</td></tr>
<tr class="separator:ga056d78564708ec422d408c360503c061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5405176b590a8a23d7267adeef532657"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a5405176b590a8a23d7267adeef532657"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a5405176b590a8a23d7267adeef532657">get_fe_from_name</a> (const std::string &amp;parameter_name)</td></tr>
<tr class="separator:a5405176b590a8a23d7267adeef532657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generation of local matrices</div></td></tr>
<tr class="memitem:ab1e885987df913c64885ece9034b5c44"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:ab1e885987df913c64885ece9034b5c44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ab1e885987df913c64885ece9034b5c44">get_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;interpolation_matrix)</td></tr>
<tr class="separator:ab1e885987df913c64885ece9034b5c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6ade80f618ca06382d4cdc04cc0940"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a3a6ade80f618ca06382d4cdc04cc0940"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a3a6ade80f618ca06382d4cdc04cc0940">get_back_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;interpolation_matrix)</td></tr>
<tr class="separator:a3a6ade80f618ca06382d4cdc04cc0940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebb94b65dba9e3790ea358afbc0d274"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:aeebb94b65dba9e3790ea358afbc0d274"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aeebb94b65dba9e3790ea358afbc0d274">get_interpolation_difference_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;difference_matrix)</td></tr>
<tr class="separator:aeebb94b65dba9e3790ea358afbc0d274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415b74d2b5da88cfc78d8ef00f0bbfab"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a415b74d2b5da88cfc78d8ef00f0bbfab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a415b74d2b5da88cfc78d8ef00f0bbfab">get_projection_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;matrix)</td></tr>
<tr class="separator:a415b74d2b5da88cfc78d8ef00f0bbfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3d342cc4d853430f07ad49d8bf2eab"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aec3d342cc4d853430f07ad49d8bf2eab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aec3d342cc4d853430f07ad49d8bf2eab">compute_node_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe)</td></tr>
<tr class="separator:aec3d342cc4d853430f07ad49d8bf2eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab655f76abed08ac8040373bea77ea419"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:ab655f76abed08ac8040373bea77ea419"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ab655f76abed08ac8040373bea77ea419">compute_embedding_matrices</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &gt; &gt; &amp;matrices, const bool isotropic_only=false, const double threshold=1.e-12)</td></tr>
<tr class="separator:ab655f76abed08ac8040373bea77ea419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fe5c7f55db091a4477af7c3989b83c"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:ac0fe5c7f55db091a4477af7c3989b83c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ac0fe5c7f55db091a4477af7c3989b83c">compute_face_embedding_matrices</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;(&amp;matrices)[<a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::max_children_per_face], const unsigned int face_coarse, const unsigned int face_fine, const double threshold=1.e-12)</td></tr>
<tr class="separator:ac0fe5c7f55db091a4477af7c3989b83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d4cc00c2a413d837e33d65d4becc4a"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:af2d4cc00c2a413d837e33d65d4becc4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#af2d4cc00c2a413d837e33d65d4becc4a">compute_projection_matrices</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &gt; &gt; &amp;matrices, const bool isotropic_only=false)</td></tr>
<tr class="separator:af2d4cc00c2a413d837e33d65d4becc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a0545c897ee022029f8c5f2c252735"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab1a0545c897ee022029f8c5f2c252735"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">compute_projection_from_quadrature_points_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;lhs_quadrature, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;rhs_quadrature, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;X)</td></tr>
<tr class="separator:ab1a0545c897ee022029f8c5f2c252735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860d229b5510b389a562ed701ad83811"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a860d229b5510b389a562ed701ad83811"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a860d229b5510b389a562ed701ad83811">compute_interpolation_to_quadrature_points_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;I_q)</td></tr>
<tr class="separator:a860d229b5510b389a562ed701ad83811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c2ca67f06c280e784936238d60439b"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a27c2ca67f06c280e784936238d60439b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a27c2ca67f06c280e784936238d60439b">compute_projection_from_quadrature_points</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;projection_matrix, const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;vector_of_tensors_at_qp, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;vector_of_tensors_at_nodes)</td></tr>
<tr class="separator:a27c2ca67f06c280e784936238d60439b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193da89bd69465aec120b2a2f159533d"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a193da89bd69465aec120b2a2f159533d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a193da89bd69465aec120b2a2f159533d">compute_projection_from_quadrature_points</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;projection_matrix, const std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt; &gt; &amp;vector_of_tensors_at_qp, std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt; &gt; &amp;vector_of_tensors_at_nodes)</td></tr>
<tr class="separator:a193da89bd69465aec120b2a2f159533d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf0993a1b0c400670b079a8186b2360"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8bf0993a1b0c400670b079a8186b2360"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a8bf0993a1b0c400670b079a8186b2360">compute_projection_from_face_quadrature_points_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;lhs_quadrature, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;rhs_quadrature, const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell, const unsigned int face, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;X)</td></tr>
<tr class="separator:a8bf0993a1b0c400670b079a8186b2360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions which should be in DoFTools</div></td></tr>
<tr class="memitem:a6eb5c7c53ff3461a80c39f34ed2913d0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType1, template&lt; int, int &gt; class DoFHandlerType2, class InVector , class OutVector &gt; </td></tr>
<tr class="memitem:a6eb5c7c53ff3461a80c39f34ed2913d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a6eb5c7c53ff3461a80c39f34ed2913d0">interpolate</a> (const DoFHandlerType1&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const DoFHandlerType2&lt; dim, spacedim &gt; &amp;dof2, OutVector &amp;u2)</td></tr>
<tr class="separator:a6eb5c7c53ff3461a80c39f34ed2913d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9e3eac1edd11e6821d2c20ef6b2e04"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType1, template&lt; int, int &gt; class DoFHandlerType2, class InVector , class OutVector &gt; </td></tr>
<tr class="memitem:a0a9e3eac1edd11e6821d2c20ef6b2e04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a0a9e3eac1edd11e6821d2c20ef6b2e04">interpolate</a> (const DoFHandlerType1&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const DoFHandlerType2&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, OutVector &amp;u2)</td></tr>
<tr class="separator:a0a9e3eac1edd11e6821d2c20ef6b2e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afc0f64809e8ccccb8cc3b6a018b584"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class DoFHandlerType, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a0afc0f64809e8ccccb8cc3b6a018b584"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a0afc0f64809e8ccccb8cc3b6a018b584">back_interpolate</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, OutVector &amp;u1_interpolated)</td></tr>
<tr class="separator:a0afc0f64809e8ccccb8cc3b6a018b584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab27f4acb5bb40f3486af5341ee3f98b"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:aab27f4acb5bb40f3486af5341ee3f98b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aab27f4acb5bb40f3486af5341ee3f98b">back_interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints1, const InVector &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints2, OutVector &amp;u1_interpolated)</td></tr>
<tr class="separator:aab27f4acb5bb40f3486af5341ee3f98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2e45e9f0117e1ae3ca704885c96ebc"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a0f2e45e9f0117e1ae3ca704885c96ebc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a0f2e45e9f0117e1ae3ca704885c96ebc">interpolation_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;z1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, OutVector &amp;z1_difference)</td></tr>
<tr class="separator:a0f2e45e9f0117e1ae3ca704885c96ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eca657cb613f5ae67bb94be051b58d4"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a4eca657cb613f5ae67bb94be051b58d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a4eca657cb613f5ae67bb94be051b58d4">interpolation_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints1, const InVector &amp;z1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints2, OutVector &amp;z1_difference)</td></tr>
<tr class="separator:a4eca657cb613f5ae67bb94be051b58d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3ad6cbc7cef0f14e60f3ae5a3a5115"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a2a3ad6cbc7cef0f14e60f3ae5a3a5115"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a2a3ad6cbc7cef0f14e60f3ae5a3a5115">project_dg</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, OutVector &amp;u2)</td></tr>
<tr class="separator:a2a3ad6cbc7cef0f14e60f3ae5a3a5115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c5f72f3b99909fdf7d7bb215792400"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:ab2c5f72f3b99909fdf7d7bb215792400"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ab2c5f72f3b99909fdf7d7bb215792400">extrapolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;z1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, OutVector &amp;z2)</td></tr>
<tr class="separator:ab2c5f72f3b99909fdf7d7bb215792400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb266657f56c7504ab3e23e87188a2f"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a5eb266657f56c7504ab3e23e87188a2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a5eb266657f56c7504ab3e23e87188a2f">extrapolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;z1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, OutVector &amp;z2)</td></tr>
<tr class="separator:a5eb266657f56c7504ab3e23e87188a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace offers interpolations and extrapolations of discrete functions of one <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> <code>fe1</code> to another <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> <code>fe2</code>.</p>
<p>It also provides the local interpolation matrices that interpolate on each cell. Furthermore it provides the difference matrix <img class="formulaInl" alt="$id-I_h$" src="form_696.png"/> that is needed for evaluating <img class="formulaInl" alt="$(id-I_h)z$" src="form_697.png"/> for e.g. the dual solution <img class="formulaInl" alt="$z$" src="form_11.png"/>.</p>
<p>For more information about the <code>spacedim</code> template parameter check the documentation of <a class="el" href="classFiniteElement.html">FiniteElement</a> or the one of <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Ralf Hartmann, Guido Kanschat; 2000, 2003, 2004, 2005, 2006 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4945a239d321d126dfccce60a73a4e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4945a239d321d126dfccce60a73a4e67">&#9670;&nbsp;</a></span>compute_component_wise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_component_wise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>start_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>In most cases, you will probably want to use compute_base_renumbering().</dd></dl>
<p>Compute the vector required to renumber the dofs of a cell by component. Furthermore, compute the vector storing the start indices of each component in the local block vector.</p>
<p>The second vector is organized such that there is a vector for each base element containing the start index for each component served by this base element.</p>
<p>While the first vector is checked to have the correct size, the second one is reinitialized for convenience. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l01325">1325</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="ad7f8f27696c0adadc316996b7281f096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f8f27696c0adadc316996b7281f096">&#9670;&nbsp;</a></span>compute_block_renumbering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_block_renumbering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>return_start_indices</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the vector required to renumber the dofs of a cell by block. Furthermore, compute the vector storing either the start indices or the size of each local block vector.</p>
<p>If the <code>bool</code> parameter is true, <code>block_data</code> is filled with the start indices of each local block. If it is false, then the block sizes are returned.</p>
<p>The vector <code>renumbering</code> will be indexed by the standard numbering of local degrees of freedom, namely first first vertex, then second vertex, after vertices lines, quads, and hexes. For each index, the entry indicates the index which this degree of freedom receives in a numbering scheme, where the first block is numbered completely before the second. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l01367">1367</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="ab1e885987df913c64885ece9034b5c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e885987df913c64885ece9034b5c44">&#9670;&nbsp;</a></span>get_interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>interpolation_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation matrix that interpolates a <code>fe1-</code> function to a <code>fe2-function</code> on each cell. The interpolation_matrix needs to be of size <code>(fe2.dofs_per_cell, fe1.dofs_per_cell)</code>.</p>
<p>Note, that if the finite element space <code>fe1</code> is a subset of the finite element space <code>fe2</code> then the <code>interpolation_matrix</code> is an embedding matrix. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l01415">1415</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="a3a6ade80f618ca06382d4cdc04cc0940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6ade80f618ca06382d4cdc04cc0940">&#9670;&nbsp;</a></span>get_back_interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_back_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>interpolation_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation matrix that interpolates a <code>fe1-</code> function to a <code>fe2-function</code>, and interpolates this to a second <code>fe1-function</code> on each cell. The interpolation_matrix needs to be of size <code>(fe1.dofs_per_cell, fe1.dofs_per_cell)</code>.</p>
<p>Note, that this function only makes sense if the finite element space due to <code>fe1</code> is not a subset of the finite element space due to <code>fe2</code>, as if it were a subset then the <code>interpolation_matrix</code> would be only the unit matrix. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l01479">1479</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="aeebb94b65dba9e3790ea358afbc0d274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebb94b65dba9e3790ea358afbc0d274">&#9670;&nbsp;</a></span>get_interpolation_difference_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_interpolation_difference_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>difference_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the unit matrix minus the back interpolation matrix. The <code>difference_matrix</code> needs to be of size <code>(fe1.dofs_per_cell, fe1.dofs_per_cell)</code>.</p>
<p>This function gives the matrix that transforms a <code>fe1</code> function <img class="formulaInl" alt="$z$" src="form_11.png"/> to <img class="formulaInl" alt="$z-I_hz$" src="form_698.png"/> where <img class="formulaInl" alt="$I_h$" src="form_699.png"/> denotes the interpolation operator from the <code>fe1</code> space to the <code>fe2</code> space. This matrix hence is useful to evaluate error- representations where <img class="formulaInl" alt="$z$" src="form_11.png"/> denotes the dual solution. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l01505">1505</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="a415b74d2b5da88cfc78d8ef00f0bbfab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415b74d2b5da88cfc78d8ef00f0bbfab">&#9670;&nbsp;</a></span>get_projection_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_projection_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the local <img class="formulaInl" alt="$L^2$" src="form_700.png"/>-projection matrix from fe1 to fe2. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l01531">1531</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="aec3d342cc4d853430f07ad49d8bf2eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3d342cc4d853430f07ad49d8bf2eab">&#9670;&nbsp;</a></span>compute_node_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; FETools::compute_node_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a rather specialized function used during the construction of finite element objects. It is used to build the basis of shape functions for an element, given a set of polynomials and interpolation points. The function is only implemented for finite elements with exactly <code>dim</code> vector components. In particular, this applies to classes derived from the <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a> class.</p>
<p>Specifically, the purpose of this function is as follows: <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a> receives, from its derived classes, an argument that describes a polynomial space. This space may be parameterized in terms of monomials, or in some other way, but is in general not in the form that we use for finite elements where we typically want to use a basis that is derived from some kind of node functional (e.g., the interpolation at specific points). Concretely, assume that the basis used by the polynomial space is <img class="formulaInl" alt="$\{\tilde\varphi_j(\mathbf x)\}_{j=1}^N$" src="form_701.png"/>, and that the node functionals of the finite element are <img class="formulaInl" alt="$\{\Psi_i\}_{i=1}^N$" src="form_702.png"/>. We then want to compute a basis <img class="formulaInl" alt="$\{\varphi_j(\mathbf x)\}_{j=1}^N$" src="form_703.png"/> for the finite element space so that <img class="formulaInl" alt="$\Psi_i[\varphi_j] = \delta_{ij}$" src="form_704.png"/>. To do this, we can set <img class="formulaInl" alt="$\varphi_j(\mathbf x) = \sum_{k=1}^N c_{jk} \tilde\varphi_k(\mathbf x)$" src="form_705.png"/> where we need to determine the expansion coefficients <img class="formulaInl" alt="$c_{jk}$" src="form_661.png"/>. We do this by applying <img class="formulaInl" alt="$\Psi_i$" src="form_590.png"/> to both sides of the equation, to obtain </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \Psi_i [\varphi_j] = \sum_{k=1}^N c_{jk} \Psi_i[\tilde\varphi_k], \end{align*}" src="form_706.png"/>
</p>
<p> and we know that the left hand side equals <img class="formulaInl" alt="$\delta_{ij}$" src="form_88.png"/>. If you think of this as a system of <img class="formulaInl" alt="$N\times N$" src="form_707.png"/> equations for the elements of a matrix on the left and on the right, then this can be written as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} I = C X^T \end{align*}" src="form_708.png"/>
</p>
<p> where <img class="formulaInl" alt="$C$" src="form_43.png"/> is the matrix of coefficients <img class="formulaInl" alt="$c_{jk}$" src="form_661.png"/> and <img class="formulaInl" alt="$X_{ik} = \Psi_i[\tilde\varphi_k]$" src="form_709.png"/>. Consequently, in order to compute the expansion coefficients <img class="formulaInl" alt="$C=X^{-T}$" src="form_710.png"/>, we need to apply the node functionals to all functions of the "raw" basis of the polynomial space.</p>
<p>Until the finite element receives this matrix <img class="formulaInl" alt="$X$" src="form_711.png"/> back, it describes its shape functions (e.g., in <a class="el" href="classFiniteElement.html#a9889833bef170393b1281a1418596d70">FiniteElement::shape_value()</a>) in the form <img class="formulaInl" alt="$\tilde\varphi_j$" src="form_712.png"/>. After it calls this function, it has the expansion coefficients and can describe its shape functions as <img class="formulaInl" alt="$\varphi_j$" src="form_532.png"/>.</p>
<p>This function therefore computes this matrix <img class="formulaInl" alt="$X$" src="form_711.png"/>, for the following specific circumstances:</p><ul>
<li>That the node functionals <img class="formulaInl" alt="$\Psi_i$" src="form_590.png"/> are point evaluations at points <img class="formulaInl" alt="$\mathbf x_i$" src="form_713.png"/> that the finite element in question describes via its "generalized" support points (through <a class="el" href="classFiniteElement.html#acd7d4db3494e48ce40d49da6f2c7d4b2">FiniteElement::get_generalized_support_points()</a>, see also <a class="el" href="DEALGlossary.html#GlossGeneralizedSupport">this glossary entry</a>). These point evaluations need to necessarily evaluate the <em>value</em> of a shape function at that point (the shape function may be vector-valued, and so the functional may be a linear combination of the individual components of the values); but, in particular, the nodal functions may not be <em>integrals</em> over entire edges or faces, or other non-local functionals. In other words, we assume that <img class="formulaInl" alt="$\Psi_i[\tilde\varphi_j] = f_j(\tilde\varphi_j(\mathbf x_i))$" src="form_714.png"/> where <img class="formulaInl" alt="$f_j$" src="form_715.png"/> is a function of the (possibly vector-valued) argument that returns a scalar.</li>
<li>That the finite element has exactly <code>dim</code> vector components.</li>
<li>That the function <img class="formulaInl" alt="$f_j$" src="form_715.png"/> is given by whatever the element implements through the <a class="el" href="classFiniteElement.html#a69948e87907f6b146c6c8bdf0cabdf22">FiniteElement::convert_generalized_support_point_values_to_nodal_values()</a> function.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td>The finite element for which the operations above are to be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix <img class="formulaInl" alt="$X$" src="form_711.png"/> as discussed above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l01616">1616</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="ab655f76abed08ac8040373bea77ea419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab655f76abed08ac8040373bea77ea419">&#9670;&nbsp;</a></span>compute_embedding_matrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_embedding_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isotropic_only</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1.e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For all possible (isotropic and anisotropic) refinement cases compute the embedding matrices from a coarse cell to the child cells. Each column of the resulting matrices contains the representation of a coarse grid basis function by the fine grid basis; the matrices are split such that there is one matrix for every child.</p>
<p>This function computes the coarse grid function in a sufficiently large number of quadrature points and fits the fine grid functions using least squares approximation. Therefore, the use of this function is restricted to the case that the finite element spaces are actually nested.</p>
<p>Note, that <code>matrices[refinement_case-1][child]</code> includes the embedding (or prolongation) matrix of child <code>child</code> for the <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code>. Here, we use <code>refinement_case-1</code> instead of <code>refinement_case</code> as for <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase::no_refinement</a>(=0) there are no prolongation matrices available.</p>
<p>Typically this function is called by the various implementations of <a class="el" href="classFiniteElement.html">FiniteElement</a> classes in order to fill the respective <a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">FiniteElement::prolongation</a> matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td>The finite element class for which we compute the embedding matrices.</td></tr>
    <tr><td class="paramname">matrices</td><td>A reference to <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8aadbd360e28038a2c4f89f7af40475b7c">RefinementCase&lt;dim&gt;::isotropic_refinement</a> vectors of <a class="el" href="classFullMatrix.html">FullMatrix</a> objects. Each vector corresponds to one <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code> and is of the vector size GeometryInfo&lt;dim&gt;::n_children(refinement_case). This is the format used in <a class="el" href="classFiniteElement.html">FiniteElement</a>, where we want to use this function mostly.</td></tr>
    <tr><td class="paramname">isotropic_only</td><td>Set to <code>true</code> if you only want to compute matrices for isotropic refinement.</td></tr>
    <tr><td class="paramname">threshold</td><td>is the gap allowed in the least squares algorithm computing the embedding. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l01887">1887</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="ac0fe5c7f55db091a4477af7c3989b83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0fe5c7f55db091a4477af7c3989b83c">&#9670;&nbsp;</a></span>compute_face_embedding_matrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_face_embedding_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>matrices</em>[GeometryInfo&lt; dim &gt;::max_children_per_face], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face_coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face_fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1.e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the embedding matrices on faces needed for constraint matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td>The finite element for which to compute these matrices.</td></tr>
    <tr><td class="paramname">matrices</td><td>An array of <em>GeometryInfo&lt;dim&gt;::subfaces_per_face = 2<sup>dim-1</sup></em> <a class="el" href="classFullMatrix.html">FullMatrix</a> objects,holding the embedding matrix for each subface.</td></tr>
    <tr><td class="paramname">face_coarse</td><td>The number of the face on the coarse side of the face for which this is computed.</td></tr>
    <tr><td class="paramname">face_fine</td><td>The number of the face on the refined side of the face for which this is computed.</td></tr>
    <tr><td class="paramname">threshold</td><td>is the gap allowed in the least squares algorithm computing the embedding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function will be used in computing constraint matrices. It is not sufficiently tested yet. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l01910">1910</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="af2d4cc00c2a413d837e33d65d4becc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d4cc00c2a413d837e33d65d4becc4a">&#9670;&nbsp;</a></span>compute_projection_matrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isotropic_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For all possible (isotropic and anisotropic) refinement cases compute the <em>L<sup>2</sup></em>-projection matrices from the children to a coarse cell.</p>
<p>Note, that <code>matrices[refinement_case-1][child]</code> includes the projection (or restriction) matrix of child <code>child</code> for the <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code>. Here, we use <code>refinement_case-1</code> instead of <code>refinement_case</code> as for <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase::no_refinement</a>(=0) there are no projection matrices available.</p>
<p>Typically this function is called by the various implementations of <a class="el" href="classFiniteElement.html">FiniteElement</a> classes in order to fill the respective <a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">FiniteElement::restriction</a> matrices.</p>
<ul>
<li>fe The finite element class for which we compute the projection matrices. </li>
<li>matrices A reference to <code><a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8aadbd360e28038a2c4f89f7af40475b7c">RefinementCase&lt;dim&gt;::isotropic_refinement</a></code> vectors of <a class="el" href="classFullMatrix.html">FullMatrix</a> objects. Each vector corresponds to one <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code> and is of the vector size <code>GeometryInfo&lt;dim&gt;::n_children(refinement_case)</code>. This is the format used in <a class="el" href="classFiniteElement.html">FiniteElement</a>, where we want to use this function mostly.</li>
</ul>
<ul>
<li>isotropic_only Set to <code>true</code> if you only want to compute matrices for isotropic refinement. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l02113">2113</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="ab1a0545c897ee022029f8c5f2c252735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a0545c897ee022029f8c5f2c252735">&#9670;&nbsp;</a></span>compute_projection_from_quadrature_points_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_quadrature_points_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Projects scalar data defined in quadrature points to a finite element space on a single cell.</p>
<p>What this function does is the following: assume that there is scalar data <code>u<sub>q</sub>, 0 &lt;= q &lt; Q:=quadrature.size()</code> defined at the quadrature points of a cell, with the points defined by the given <code>rhs_quadrature</code> object. We may then want to ask for that finite element function (on a single cell) <code>v<sub>h</sub></code> in the finite- dimensional space defined by the given FE object that is the projection of <code>u</code> in the following sense:</p>
<p>Usually, the projection <code>v<sub>h</sub></code> is that function that satisfies <code>(v<sub>h</sub>,w)=(u,w)</code> for all discrete test functions <code>w</code>. In the present case, we can't evaluate the right hand side, since <code>u</code> is only defined in the quadrature points given by <code>rhs_quadrature</code>, so we replace it by a quadrature approximation. Likewise, the left hand side is approximated using the <code>lhs_quadrature</code> object; if this quadrature object is chosen appropriately, then the integration of the left hand side can be done exactly, without any approximation. The use of different quadrature objects is necessary if the quadrature object for the right hand side has too few quadrature points &ndash; for example, if data <code>q</code> is only defined at the cell center, then the corresponding one-point quadrature formula is obviously insufficient to approximate the scalar product on the left hand side by a definite form.</p>
<p>After these quadrature approximations, we end up with a nodal representation <code>V<sub>h</sub></code> of <code>v<sub>h</sub></code> that satisfies the following system of linear equations: <code>M V<sub>h</sub> = Q U</code>, where <code>M<sub>ij</sub>=(phi_i,phi_j)</code> is the mass matrix approximated by <code>lhs_quadrature</code>, and <code>Q</code> is the matrix <code>Q<sub>iq</sub>=phi<sub>i</sub>(x<sub>q</sub>) w<sub>q</sub></code> where <code>w<sub>q</sub></code> are quadrature weights; <code>U</code> is the vector of quadrature point data <code>u<sub>q</sub></code>.</p>
<p>In order to then get the nodal representation <code>V<sub>h</sub></code> of the projection of <code>U</code>, one computes <code>V<sub>h</sub> = X U, X=M<sup>-1</sup> Q</code>. The purpose of this function is to compute the matrix <code>X</code> and return it through the last argument of this function.</p>
<p>Note that this function presently only supports scalar data. An extension of the mass matrix is of course trivial, but one has to define the order of data in the vector <code>U</code> if it contains vector valued data in all quadrature points.</p>
<p>A use for this function is described in the introduction to the <a class="el" href="step_18.html">step-18</a> example program.</p>
<p>The opposite of this function, interpolation of a finite element function onto quadrature points is essentially what the <code><a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a></code> functions do; to make things a little simpler, the <code><a class="el" href="namespaceFETools.html#a860d229b5510b389a562ed701ad83811">FETools::compute_interpolation_to_quadrature_points_matrix</a></code> provides the matrix form of this.</p>
<p>Note that this function works on a single cell, rather than an entire triangulation. In effect, it therefore doesn't matter if you use a continuous or discontinuous version of the finite element.</p>
<p>It is worth noting that there are a few confusing cases of this function. The first one is that it really only makes sense to project onto a finite element that has at most as many degrees of freedom per cell as there are quadrature points; the projection of N quadrature point data into a space with M&gt;N unknowns is well-defined, but often yields funny and non- intuitive results. Secondly, one would think that if the quadrature point data is defined in the support points of the finite element, i.e. the quadrature points of <code>ths_quadrature</code> equal <code>fe.get_unit_support_points()</code>, then the projection should be the identity, i.e. each degree of freedom of the finite element equals the value of the given data in the support point of the corresponding shape function. However, this is not generally the case: while the matrix <code>Q</code> in that case is the identity matrix, the mass matrix <code>M</code> is not equal to the identity matrix, except for the special case that the quadrature formula <code>lhs_quadrature</code> also has its quadrature points in the support points of the finite element.</p>
<p>Finally, this function only defines a cell wise projection, while one frequently wants to apply it to all cells in a triangulation. However, if it is applied to one cell after the other, the results from later cells may overwrite nodal values computed already from previous cells if degrees of freedom live on the interfaces between cells. The function is therefore most useful for discontinuous elements. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l02669">2669</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="a860d229b5510b389a562ed701ad83811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860d229b5510b389a562ed701ad83811">&#9670;&nbsp;</a></span>compute_interpolation_to_quadrature_points_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_interpolation_to_quadrature_points_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a (scalar) local finite element function, compute the matrix that maps the vector of nodal values onto the vector of values of this function at quadrature points as given by the second argument. In a sense, this function does the opposite of the <a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a> function. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l02709">2709</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="a27c2ca67f06c280e784936238d60439b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c2ca67f06c280e784936238d60439b">&#9670;&nbsp;</a></span>compute_projection_from_quadrature_points() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_quadrature_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the projection of tensorial (first-order tensor) data stored at the quadrature points <code>vector_of_tensors_at_qp</code> to data <code>vector_of_tensors_at_nodes</code> at the support points of the cell. The data in <code>vector_of_tensors_at_qp</code> is ordered sequentially following the quadrature point numbering. The size of <code>vector_of_tensors_at_qp</code> must correspond to the number of columns of <code>projection_matrix</code>. The size of <code>vector_of_tensors_at_nodes</code> must correspond to the number of rows of <code>vector_of_tensors_at_nodes</code> . The projection matrix <code>projection_matrix</code> describes the projection of scalar data from the quadrature points and can be obtained from the <a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a> function. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l02727">2727</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="a193da89bd69465aec120b2a2f159533d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193da89bd69465aec120b2a2f159533d">&#9670;&nbsp;</a></span>compute_projection_from_quadrature_points() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_quadrature_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>same as last function but for a <code><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a></code> . </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l02788">2788</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="a8bf0993a1b0c400670b079a8186b2360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf0993a1b0c400670b079a8186b2360">&#9670;&nbsp;</a></span>compute_projection_from_face_quadrature_points_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_face_quadrature_points_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method implements the <a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a> method for faces of a mesh. The matrix that it returns, X, is face specific and its size is fe.dofs_per_cell by rhs_quadrature.size(). The dimension, dim must be larger than 1 for this class, since <a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim-1&gt; objects are required. See the documentation on the <a class="el" href="classQuadrature.html">Quadrature</a> class for more information. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l02858">2858</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="a6eb5c7c53ff3461a80c39f34ed2913d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb5c7c53ff3461a80c39f34ed2913d0">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType1, template&lt; int, int &gt; class DoFHandlerType2, class InVector , class OutVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType1&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType2&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation of a the <code>dof1-function</code> <code>u1</code> to a <code>dof2-function</code> <code>u2</code>. <code>dof1</code> and <code>dof2</code> need to be DoFHandlers based on the same triangulation.</p>
<p>If the elements <code>fe1</code> and <code>fe2</code> are either both continuous or both discontinuous then this interpolation is the usual point interpolation. The same is true if <code>fe1</code> is a continuous and <code>fe2</code> is a discontinuous finite element. For the case that <code>fe1</code> is a discontinuous and <code>fe2</code> is a continuous finite element there is no point interpolation defined at the discontinuities. Therefore the mean value is taken at the DoF values on the discontinuities.</p>
<p>Note that for continuous elements on grids with hanging nodes (i.e. locally refined grids) this function does not give the expected output. Indeed, the resulting output vector does not necessarily respect continuity requirements at hanging nodes: if, for example, you are interpolating a Q2 field to a Q1 field, then at hanging nodes the output field will have the function value of the input field, which however is not usually the mean value of the two adjacent nodes. It is thus not part of the Q1 function space on the whole triangulation, although it is of course Q1 on each cell.</p>
<p>For this case (continuous elements on grids with hanging nodes), please use the <code><a class="el" href="namespaceFETools.html#a6eb5c7c53ff3461a80c39f34ed2913d0">interpolate()</a></code> function with an additional <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> argument, see below, or make the field conforming yourself by calling the <code>distribute</code> function of your hanging node constraints object. </p>

</div>
</div>
<a id="a0a9e3eac1edd11e6821d2c20ef6b2e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9e3eac1edd11e6821d2c20ef6b2e04">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType1, template&lt; int, int &gt; class DoFHandlerType2, class InVector , class OutVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType1&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType2&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation of a the <code>dof1-function</code> <code>u1</code> to a <code>dof2-function</code> <code>u2</code>. <code>dof1</code> and <code>dof2</code> need to be DoFHandlers (or hp::DoFHandlers) based on the same triangulation. <code>constraints</code> is a hanging node constraints object corresponding to <code>dof2</code>. This object is particular important when interpolating onto continuous elements on grids with hanging nodes (locally refined grids).</p>
<p>If the elements <code>fe1</code> and <code>fe2</code> are either both continuous or both discontinuous then this interpolation is the usual point interpolation. The same is true if <code>fe1</code> is a continuous and <code>fe2</code> is a discontinuous finite element. For the case that <code>fe1</code> is a discontinuous and <code>fe2</code> is a continuous finite element there is no point interpolation defined at the discontinuities. Therefore the mean value is taken at the DoF values at the discontinuities. </p>

</div>
</div>
<a id="a0afc0f64809e8ccccb8cc3b6a018b584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afc0f64809e8ccccb8cc3b6a018b584">&#9670;&nbsp;</a></span>back_interpolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class DoFHandlerType, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::back_interpolate </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u1_interpolated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation of the <code>fe1-function</code> <code>u1</code> to a <code>fe2-function</code>, and interpolates this to a second <code>fe1-function</code> named <code>u1_interpolated</code>.</p>
<p>Note, that this function does not work on continuous elements at hanging nodes. For that case use the <code>back_interpolate</code> function, below, that takes an additional <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a></code> object.</p>
<p><code>dof1</code> might be a <a class="el" href="classDoFHandler.html">DoFHandler</a> or a <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> onject.</p>
<p>Furthermore note, that for the specific case when the finite element space corresponding to <code>fe1</code> is a subset of the finite element space corresponding to <code>fe2</code>, this function is simply an identity mapping. </p>

</div>
</div>
<a id="aab27f4acb5bb40f3486af5341ee3f98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab27f4acb5bb40f3486af5341ee3f98b">&#9670;&nbsp;</a></span>back_interpolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::back_interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u1_interpolated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation of the <code>dof1-function</code> <code>u1</code> to a <code>dof2-function</code>, and interpolates this to a second <code>dof1-function</code> named <code>u1_interpolated</code>. <code>constraints1</code> and <code>constraints2</code> are the hanging node constraints corresponding to <code>dof1</code> and <code>dof2</code>, respectively. These objects are particular important when continuous elements on grids with hanging nodes (locally refined grids) are involved.</p>
<p>Furthermore note, that for the specific case when the finite element space corresponding to <code>dof1</code> is a subset of the finite element space corresponding to <code>dof2</code>, this function is simply an identity mapping. </p>

</div>
</div>
<a id="a0f2e45e9f0117e1ae3ca704885c96ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2e45e9f0117e1ae3ca704885c96ebc">&#9670;&nbsp;</a></span>interpolation_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolation_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z1_difference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives <img class="formulaInl" alt="$(Id-I_h)z_1$" src="form_716.png"/> for a given <code>dof1-function</code> <img class="formulaInl" alt="$z_1$" src="form_717.png"/>, where <img class="formulaInl" alt="$I_h$" src="form_699.png"/> is the interpolation from <code>fe1</code> to <code>fe2</code>. The result <img class="formulaInl" alt="$(Id-I_h)z_1$" src="form_716.png"/> is written into <code>z1_difference</code>.</p>
<p>Note, that this function does not work for continuous elements at hanging nodes. For that case use the <code>interpolation_difference</code> function, below, that takes an additional <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a></code> object. </p>

</div>
</div>
<a id="a4eca657cb613f5ae67bb94be051b58d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eca657cb613f5ae67bb94be051b58d4">&#9670;&nbsp;</a></span>interpolation_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolation_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z1_difference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives <img class="formulaInl" alt="$(Id-I_h)z_1$" src="form_716.png"/> for a given <code>dof1-function</code> <img class="formulaInl" alt="$z_1$" src="form_717.png"/>, where <img class="formulaInl" alt="$I_h$" src="form_699.png"/> is the interpolation from <code>fe1</code> to <code>fe2</code>. The result <img class="formulaInl" alt="$(Id-I_h)z_1$" src="form_716.png"/> is written into <code>z1_difference</code>. <code>constraints1</code> and <code>constraints2</code> are the hanging node constraints corresponding to <code>dof1</code> and <code>dof2</code>, respectively. These objects are particular important when continuous elements on grids with hanging nodes (locally refined grids) are involved.</p>
<p>For parallel computations with PETSc, supply <code>z1</code> with ghost elements and <code>z1_difference</code> without ghost elements. </p>

</div>
</div>
<a id="a2a3ad6cbc7cef0f14e60f3ae5a3a5115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3ad6cbc7cef0f14e60f3ae5a3a5115">&#9670;&nbsp;</a></span>project_dg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::project_dg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><img class="formulaInl" alt="$L^2$" src="form_700.png"/> projection for discontinuous elements. Operates the same direction as interpolate.</p>
<p>The global projection can be computed by local matrices if the finite element spaces are discontinuous. With continuous elements, this is impossible, since a global mass matrix must be inverted. </p>

</div>
</div>
<a id="ab2c5f72f3b99909fdf7d7bb215792400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c5f72f3b99909fdf7d7bb215792400">&#9670;&nbsp;</a></span>extrapolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::extrapolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the patchwise extrapolation of a <code>dof1</code> function <code>z1</code> to a <code>dof2</code> function <code>z2</code>. <code>dof1</code> and <code>dof2</code> need to be <a class="el" href="classDoFHandler.html">DoFHandler</a> objects based on the same triangulation. This function is used, for example, for extrapolating patchwise a piecewise linear solution to a piecewise quadratic solution.</p>
<p>The function's name is historical and probably not particularly well chosen. The function performs the following operations, one after the other:</p>
<ul>
<li>It interpolates directly from every cell of <code>dof1</code> to the corresponding cell of <code>dof2</code> using the interpolation matrix of the finite element spaces used on these cells and provided by the finite element objects involved. This step is done using the <a class="el" href="namespaceFETools.html#a6eb5c7c53ff3461a80c39f34ed2913d0">FETools::interpolate()</a> function.</li>
<li>It then performs a loop over all non-active cells of <code>dof2</code>. If such a non-active cell has at least one active child, then we call the children of this cell a "patch". We then interpolate from the children of this patch to the patch, using the finite element space associated with <code>dof2</code> and immediately interpolate back to the children. In essence, this information throws away all information in the solution vector that lives on a scale smaller than the patch cell.</li>
<li>Since we traverse non-active cells from the coarsest to the finest levels, we may find patches that correspond to child cells of previously treated patches if the mesh had been refined adaptively (this cannot happen if the mesh has been refined globally because there the children of a patch are all active). We also perform the operation described above on these patches, but it is easy to see that on patches that are children of previously treated patches, the operation is now the identity operation (since it interpolates from the children of the current patch a function that had previously been interpolated to these children from an even coarser patch). Consequently, this does not alter the solution vector any more.</li>
</ul>
<p>The name of the function originates from the fact that it can be used to construct a representation of a function of higher polynomial degree on a once coarser mesh. For example, if you imagine that you start with a <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> function on a globally refined mesh, and that <code>dof2</code> is associated with a <img class="formulaInl" alt="$Q_2$" src="form_575.png"/> element, then this function computes the equivalent of the operator <img class="formulaInl" alt="$I_{2h}^{(2)}$" src="form_718.png"/> interpolating the original piecewise linear function onto a quadratic function on a once coarser mesh with mesh size <img class="formulaInl" alt="$2h$" src="form_719.png"/> (but representing this function on the original mesh with size <img class="formulaInl" alt="$h$" src="form_720.png"/>). If the exact solution is sufficiently smooth, then <img class="formulaInl" alt="$u^\ast=I_{2h}^{(2)}u_h$" src="form_721.png"/> is typically a better approximation to the exact solution <img class="formulaInl" alt="$u$" src="form_256.png"/> of the PDE than <img class="formulaInl" alt="$u_h$" src="form_722.png"/> is. In other words, this function provides a postprocessing step that improves the solution in a similar way one often obtains by extrapolating a sequence of solutions, explaining the origin of the function's name.</p>
<dl class="section note"><dt>Note</dt><dd>The resulting field does not satisfy continuity requirements of the given finite elements if the algorithm outlined above is used. When you use continuous elements on grids with hanging nodes, please use the <code>extrapolate</code> function with an additional <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> argument, see below.</dd>
<dd>
Since this function operates on patches of cells, it requires that the underlying grid is refined at least once for every coarse grid cell. If this is not the case, an exception will be raised. </dd></dl>

</div>
</div>
<a id="a5eb266657f56c7504ab3e23e87188a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb266657f56c7504ab3e23e87188a2f">&#9670;&nbsp;</a></span>extrapolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::extrapolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the patchwise extrapolation of a <code>dof1</code> function <code>z1</code> to a <code>dof2</code> function <code>z2</code>. <code>dof1</code> and <code>dof2</code> need to be <a class="el" href="classDoFHandler.html">DoFHandler</a> objects based on the same triangulation. <code>constraints</code> is a hanging node constraints object corresponding to <code>dof2</code>. This object is necessary when interpolating onto continuous elements on grids with hanging nodes (locally refined grids).</p>
<p>Otherwise, the function does the same as the other <code>extrapolate</code> function above (for which the documentation provides an extensive description of its operation). </p>

</div>
</div>
<a id="a42118e6f1c76038d4ac41ebf140a4b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42118e6f1c76038d4ac41ebf140a4b62">&#9670;&nbsp;</a></span>hierarchic_to_lexicographic_numbering() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::hierarchic_to_lexicographic_numbering </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>h2l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The numbering of the degrees of freedom in continuous finite elements is hierarchic, i.e. in such a way that we first number the vertex dofs, in the order of the vertices as defined by the triangulation, then the line dofs in the order and respecting the direction of the lines, then the dofs on quads, etc. However, we could have, as well, numbered them in a lexicographic way, i.e. with indices first running in x-direction, then in y-direction and finally in z-direction. Discontinuous elements of class <a class="el" href="classFE__DGQ.html">FE_DGQ()</a> are numbered in this way, for example.</p>
<p>This function constructs a table which lexicographic index each degree of freedom in the hierarchic numbering would have. It operates on the continuous finite element given as first argument, and outputs the lexicographic indices in the second.</p>
<p>Note that since this function uses specifics of the continuous finite elements, it can only operate on FiniteElementData&lt;dim&gt; objects inherent in <a class="el" href="classFE__Q.html">FE_Q()</a>. However, this function does not take a <a class="el" href="classFE__Q.html">FE_Q</a> object as it is also invoked by the <a class="el" href="classFE__Q.html">FE_Q()</a> constructor.</p>
<p>It is assumed that the size of the output argument already matches the correct size, which is equal to the number of degrees of freedom in the finite element. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l02918">2918</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="a336ef517d9517ab78bbaea2499cfe801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336ef517d9517ab78bbaea2499cfe801">&#9670;&nbsp;</a></span>hierarchic_to_lexicographic_numbering() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; FETools::hierarchic_to_lexicographic_numbering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function but instead of returning its result through the last argument return it as a value. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l03098">3098</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="a1db6ab2ac1c2318f07fc020756cf76b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db6ab2ac1c2318f07fc020756cf76b9">&#9670;&nbsp;</a></span>lexicographic_to_hierarchic_numbering() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::lexicographic_to_hierarchic_numbering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>l2h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the reverse function to the above one, generating the map from the lexicographic to the hierarchical numbering. All the remarks made about the above function are also valid here. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l03110">3110</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="aafd88ec1f100c5b1cf1add3669d5d696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd88ec1f100c5b1cf1add3669d5d696">&#9670;&nbsp;</a></span>lexicographic_to_hierarchic_numbering() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; FETools::lexicographic_to_hierarchic_numbering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function but instead of returning its result through the last argument return it as a value. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l03120">3120</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="aa8f65ecfe844cd5221a57290fa411d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f65ecfe844cd5221a57290fa411d07">&#9670;&nbsp;</a></span>get_fe_by_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; * FETools::get_fe_by_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the name of a finite element and generate a finite element object accordingly. The parser ignores space characters between words (things matching the regular expression [A-Za-z0-9_]).</p>
<p>The name must be in the form which is returned by the <a class="el" href="classFiniteElement.html#a09655d1d2555af8dcd48caebd4039d29">FiniteElement::get_name</a> function, where dimension template parameters &lt;2&gt; etc. can be omitted. Alternatively, the explicit number can be replaced by <code>dim</code> or <code>d</code>. If a number is given, it <b>must</b> match the template parameter of this function.</p>
<p>The names of <a class="el" href="classFESystem.html">FESystem</a> elements follow the pattern <code><a class="el" href="classFESystem.html">FESystem</a>[FE_Base1^p1-FE_Base2^p2]</code> The powers <code>p1</code> etc. may either be numbers or can be replaced by <code>dim</code> or <code>d</code>.</p>
<p>If no finite element can be reconstructed from this string, an exception of type <code><a class="el" href="group__Exceptions.html#ga29863aa7dd0b071bb6794c7780b59ff8">FETools::ExcInvalidFEName</a></code> is thrown.</p>
<p>The function returns a pointer to a newly create finite element. It is in the caller's responsibility to destroy the object pointed to at an appropriate later time.</p>
<p>Since the value of the template argument can't be deduced from the (string) argument given to this function, you have to explicitly specify it when you call this function.</p>
<p>This function knows about all the standard elements defined in the library. However, it doesn't by default know about elements that you may have defined in your program. To make your own elements known to this function, use the <a class="el" href="namespaceFETools.html#a5a006641198ca5641c5c8ae20b741b4b">add_fe_name()</a> function. This function does not work if one wants to get a codimension 1 finite element. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l02579">2579</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="aad274d541ca470e7295b4485eb5b1083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad274d541ca470e7295b4485eb5b1083">&#9670;&nbsp;</a></span>get_fe_from_name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim,dim&gt;* FETools::get_fe_from_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>Use <a class="el" href="namespaceFETools.html#aa8f65ecfe844cd5221a57290fa411d07">get_fe_by_name()</a> with two template parameters instead </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l02570">2570</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="a5a006641198ca5641c5c8ae20b741b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a006641198ca5641c5c8ae20b741b4b">&#9670;&nbsp;</a></span>add_fe_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::add_fe_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFETools_1_1FEFactoryBase.html">FEFactoryBase</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extend the list of finite elements that can be generated by <a class="el" href="namespaceFETools.html#aa8f65ecfe844cd5221a57290fa411d07">get_fe_by_name()</a> by the one given as <code>name</code>. If <a class="el" href="namespaceFETools.html#aa8f65ecfe844cd5221a57290fa411d07">get_fe_by_name()</a> is later called with this name, it will use the object given as second argument to create a finite element object.</p>
<p>The format of the <code>name</code> parameter should include the name of a finite element. However, it is safe to use either the class name alone or to use the result of <a class="el" href="classFiniteElement.html#a09655d1d2555af8dcd48caebd4039d29">FiniteElement::get_name</a> (which includes the space dimension as well as the polynomial degree), since everything after the first non- name character will be ignored.</p>
<p>The <a class="el" href="classFETools_1_1FEFactory.html">FEFactory</a> object should be an object newly created with <code>new</code>. <a class="el" href="namespaceFETools.html">FETools</a> will take ownership of this object and delete it once it is not used anymore.</p>
<p>In most cases, if you want objects of type <code>MyFE</code> be created whenever the name <code>my_fe</code> is given to get_fe_by_name, you will want the second argument to this function be of type <a class="el" href="classFETools_1_1FEFactory.html">FEFactory</a>&lt;MyFE&gt;, but you can of course create your custom finite element factory class.</p>
<p>This function takes over ownership of the object given as second argument, i.e. you should never attempt to destroy it later on. The object will be deleted at the end of the program's lifetime.</p>
<p>If the name of the element is already in use, an exception is thrown. Thus, functionality of <a class="el" href="namespaceFETools.html#aa8f65ecfe844cd5221a57290fa411d07">get_fe_by_name()</a> can only be added, not changed.</p>
<dl class="section note"><dt>Note</dt><dd>This function manipulates a global table (one table for each space dimension). It is thread safe in the sense that every access to this table is secured by a lock. Nevertheless, since each name can be added only once, user code has to make sure that only one thread adds a new element.</dd></dl>
<p>Note also that this table exists once for each space dimension. If you have a program that works with finite elements in different space dimensions (for example, <a class="el" href="step_4.html">step-4</a> does something like this), then you should call this function for each space dimension for which you want your finite element added to the map. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l02273">2273</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="a5405176b590a8a23d7267adeef532657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5405176b590a8a23d7267adeef532657">&#9670;&nbsp;</a></span>get_fe_from_name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt;* FETools::get_fe_from_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>Use <a class="el" href="namespaceFETools.html#aa8f65ecfe844cd5221a57290fa411d07">get_fe_by_name()</a> with two template parameters instead </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l02570">2570</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
