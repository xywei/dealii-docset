<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: OpenCASCADE Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">OpenCASCADE Namespace Reference<div class="ingroups"><a class="el" href="group__OpenCASCADE.html">OpenCASCADE</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">ArclengthProjectionLineManifold</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1DirectionalProjectionBoundary.html">DirectionalProjectionBoundary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NormalProjectionBoundary.html">NormalProjectionBoundary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionBoundary.html">NormalToMeshProjectionBoundary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">NURBSPatchManifold</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3e3e0df474c0e4f9abb627753c8754e9"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; unsigned int, unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a3e3e0df474c0e4f9abb627753c8754e9">count_elements</a> (const TopoDS_Shape &amp;shape)</td></tr>
<tr class="separator:a3e3e0df474c0e4f9abb627753c8754e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe07b496f4edf844d5f4e8d7a540295"><td class="memItemLeft" align="right" valign="top">TopoDS_Shape&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">read_IGES</a> (const std::string &amp;filename, const double scale_factor=1e-3)</td></tr>
<tr class="separator:affe07b496f4edf844d5f4e8d7a540295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd63e8b33d9ed7a231da9212f6acc391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#afd63e8b33d9ed7a231da9212f6acc391">write_IGES</a> (const TopoDS_Shape &amp;shape, const std::string &amp;filename)</td></tr>
<tr class="separator:afd63e8b33d9ed7a231da9212f6acc391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614ec9f581086ad423513dd407e9e520"><td class="memItemLeft" align="right" valign="top">TopoDS_Shape&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a614ec9f581086ad423513dd407e9e520">read_STEP</a> (const std::string &amp;filename, const double scale_factor=1e-3)</td></tr>
<tr class="separator:a614ec9f581086ad423513dd407e9e520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42404c99252b6da0977f40a4eccf05d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a42404c99252b6da0977f40a4eccf05d9">write_STEP</a> (const TopoDS_Shape &amp;shape, const std::string &amp;filename)</td></tr>
<tr class="separator:a42404c99252b6da0977f40a4eccf05d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed838d4999b4707c48781b8d732058fe"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#aed838d4999b4707c48781b8d732058fe">get_shape_tolerance</a> (const TopoDS_Shape &amp;shape)</td></tr>
<tr class="separator:aed838d4999b4707c48781b8d732058fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7143020c8f7d45356e6fe0b347f73d7"><td class="memItemLeft" align="right" valign="top">TopoDS_Shape&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ad7143020c8f7d45356e6fe0b347f73d7">intersect_plane</a> (const TopoDS_Shape &amp;in_shape, const double c_x, const double c_y, const double c_z, const double c, const double tolerance=1e-7)</td></tr>
<tr class="separator:ad7143020c8f7d45356e6fe0b347f73d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c5d614d74c4091fe75f61de5242b0a"><td class="memItemLeft" align="right" valign="top">TopoDS_Edge&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a59c5d614d74c4091fe75f61de5242b0a">join_edges</a> (const TopoDS_Shape &amp;in_shape, const double tolerance=1e-7)</td></tr>
<tr class="separator:a59c5d614d74c4091fe75f61de5242b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6754fbb50a3b0403ec30ac8d955c0cee"><td class="memItemLeft" align="right" valign="top">TopoDS_Edge&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a6754fbb50a3b0403ec30ac8d955c0cee">interpolation_curve</a> (std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &gt; &amp;curve_points, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; &amp;direction=<a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;(), const bool closed=false, const double tolerance=1e-7)</td></tr>
<tr class="separator:a6754fbb50a3b0403ec30ac8d955c0cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d463f21e1fedb10a8c64eb9aefe2e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a54d463f21e1fedb10a8c64eb9aefe2e6">extract_geometrical_shapes</a> (const TopoDS_Shape &amp;shape, std::vector&lt; TopoDS_Face &gt; &amp;faces, std::vector&lt; TopoDS_Edge &gt; &amp;edges, std::vector&lt; TopoDS_Vertex &gt; &amp;vertices)</td></tr>
<tr class="separator:a54d463f21e1fedb10a8c64eb9aefe2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7320b961707ca97cef441b2e8a296cd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a7320b961707ca97cef441b2e8a296cd8">create_triangulation</a> (const TopoDS_Face &amp;face, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 3 &gt; &amp;tria)</td></tr>
<tr class="separator:a7320b961707ca97cef441b2e8a296cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e49f50433c835c841eed35f40862560"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a1e49f50433c835c841eed35f40862560">extract_compound_shapes</a> (const TopoDS_Shape &amp;shape, std::vector&lt; TopoDS_Compound &gt; &amp;compounds, std::vector&lt; TopoDS_CompSolid &gt; &amp;compsolids, std::vector&lt; TopoDS_Solid &gt; &amp;solids, std::vector&lt; TopoDS_Shell &gt; &amp;shells, std::vector&lt; TopoDS_Wire &gt; &amp;wires)</td></tr>
<tr class="separator:a1e49f50433c835c841eed35f40862560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcce32ffcfc85a9a90be263090cb8cc5"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, TopoDS_Shape, double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#adcce32ffcfc85a9a90be263090cb8cc5">project_point_and_pull_back</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;origin, const double tolerance=1e-7)</td></tr>
<tr class="separator:adcce32ffcfc85a9a90be263090cb8cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c61bfdfb96cf38bc2dadf77184ae84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#af5c61bfdfb96cf38bc2dadf77184ae84">closest_point</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;origin, const double tolerance=1e-7)</td></tr>
<tr class="separator:af5c61bfdfb96cf38bc2dadf77184ae84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5bed4afc0363cc8f199f7bf9be4ef0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a9c5bed4afc0363cc8f199f7bf9be4ef0">push_forward</a> (const TopoDS_Shape &amp;in_shape, const double u, const double v)</td></tr>
<tr class="separator:a9c5bed4afc0363cc8f199f7bf9be4ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c7b59ea0d1fee16c815c7e40237aa5"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;, double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a17c7b59ea0d1fee16c815c7e40237aa5">push_forward_and_differential_forms</a> (const TopoDS_Face &amp;face, const double u, const double v, const double tolerance=1e-7)</td></tr>
<tr class="separator:a17c7b59ea0d1fee16c815c7e40237aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476712b60ff6cb2ad783f34552ef9843"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;, double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a476712b60ff6cb2ad783f34552ef9843">closest_point_and_differential_forms</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;origin, const double tolerance=1e-7)</td></tr>
<tr class="separator:a476712b60ff6cb2ad783f34552ef9843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db646eb968d930b5c8bb48bbbc017d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a2db646eb968d930b5c8bb48bbbc017d8">line_intersection</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;origin, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; &amp;direction, const double tolerance=1e-7)</td></tr>
<tr class="separator:a2db646eb968d930b5c8bb48bbbc017d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8e544997e65b29b37a43e82e2afcbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a> (const gp_Pnt &amp;p)</td></tr>
<tr class="separator:a7e8e544997e65b29b37a43e82e2afcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b475d2ee9eab9aec6f229aafac30ba"><td class="memItemLeft" align="right" valign="top">gp_Pnt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ab8b475d2ee9eab9aec6f229aafac30ba">point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;p)</td></tr>
<tr class="separator:ab8b475d2ee9eab9aec6f229aafac30ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3e38a559f88341a8dbf835982fe085"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#adb3e38a559f88341a8dbf835982fe085">point_compare</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;p2, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; &amp;direction=<a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;(), const double tolerance=1e-10)</td></tr>
<tr class="separator:adb3e38a559f88341a8dbf835982fe085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ae1a00147a05fc62c1dbb512974cfa7"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga6ae1a00147a05fc62c1dbb512974cfa7">ExcPointNotOnManifold</a> (<a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; arg1)</td></tr>
<tr class="separator:ga6ae1a00147a05fc62c1dbb512974cfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01bc66c731a97285005928ff29587e4b"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga01bc66c731a97285005928ff29587e4b">ExcProjectionFailed</a> (<a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; arg1)</td></tr>
<tr class="separator:ga01bc66c731a97285005928ff29587e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb77e4ae52d70b5263f508ef00b756ad"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gabb77e4ae52d70b5263f508ef00b756ad">ExcOCCError</a> (IFSelect_ReturnStatus arg1)</td></tr>
<tr class="separator:gabb77e4ae52d70b5263f508ef00b756ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99845071d7346e7872220ff0a9655fbd"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga99845071d7346e7872220ff0a9655fbd">ExcEdgeIsDegenerate</a> ()</td></tr>
<tr class="separator:ga99845071d7346e7872220ff0a9655fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada877c8a8be9c236964764de479245d9"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gada877c8a8be9c236964764de479245d9">ExcUnsupportedShape</a> ()</td></tr>
<tr class="separator:gada877c8a8be9c236964764de479245d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>We collect in this namespace all utilities which operate on <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> entities. <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> splits every object into a topological description and a geometrical entity. The basic topological description is a TopoDS_Shape. TopoDS_Shapes are light objects, and can be copied around. The closest deal.II analog is a <a class="el" href="classTriaIterator.html">TriaIterator</a>.</p>
<p>The <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> topology is designed with reference to the STEP standard ISO-10303-42. The structure is an oriented one-way graph, where parents refer to their children, and there are no back references. Abstract structure is implemented as C++ classes from the TopoDS package. A TopoDS_Shape is manipulated by value and contains 3 fields: location, orientation and a myTShape handle (of the TopoDS_TShape type). According to <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> documentation, myTShape and Location are used to share data between various shapes to save memory. For example, an edge belonging to two faces has equal Locations and myTShape fields but different Orientations (Forward in context of one face and Reversed in one of the other).</p>
<p>Valid shapes include collection of other shapes, solids, faces, edges, vertices, etc.</p>
<p>Once a topological description is available, if a concrete geometrical object can be created, the BRep classes allow one to extract the actual geometrical information from a shape.</p>
<p>This is done by inheriting abstract topology classes from the TopoDS package by those implementing a boundary representation model (from the BRep package). Only 3 types of topological objects have geometric representations â€“ vertex, edge, and face.</p>
<p>Every TopoDS_Shape can be queried to figure out what type of shape it is, and actual geometrical objects, like surfaces, curves or points, can be extracted using BRepTools.</p>
<p>In this namespace we provide readers and writers that read standard CAD files, and return a TopoDS_Shape, or that write a CAD file, given a TopoDS_Shape. Most of the functions in the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace deal with TopoDS_Shapes of one type or another, and provide interfaces to common deal.II objects, like <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classManifold.html">Manifold</a>, and so on.</p>
<p>Notice that these tools are only useful when spacedim is equal to three, since <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> only operates in three-dimensional mode.</p>
<dl class="section author"><dt>Author</dt><dd>Luca Heltai, Andrea Mola, 2011&ndash;2014. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3e3e0df474c0e4f9abb627753c8754e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3e0df474c0e4f9abb627753c8754e9">&#9670;&nbsp;</a></span>count_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; unsigned int, unsigned int, unsigned int &gt; OpenCASCADE::count_elements </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the subobjects of a shape. This function is useful to gather information about the TopoDS_Shape passed as argument. It returns the number of faces, edges and vertices (the only topological entities associated with actual geometries) which are contained in the given shape. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00093">93</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="affe07b496f4edf844d5f4e8d7a540295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe07b496f4edf844d5f4e8d7a540295">&#9670;&nbsp;</a></span>read_IGES()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Shape OpenCASCADE::read_IGES </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale_factor</em> = <code>1e-3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read IGES files and translate their content into openCascade topological entities. The option scale_factor is used to compensate for different units being used in the IGES files and in the target application. The standard unit for IGES files is millimiters. The return object is a TopoDS_Shape which contains all objects from the file. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00201">201</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="afd63e8b33d9ed7a231da9212f6acc391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd63e8b33d9ed7a231da9212f6acc391">&#9670;&nbsp;</a></span>write_IGES()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::write_IGES </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given topological shape into an IGES file. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00232">232</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a614ec9f581086ad423513dd407e9e520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614ec9f581086ad423513dd407e9e520">&#9670;&nbsp;</a></span>read_STEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Shape OpenCASCADE::read_STEP </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale_factor</em> = <code>1e-3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read STEP files and translate their content into openCascade topological entities. The option scale_factor is used to compensate for different units being used in the STEP files and in the target application. The standard unit for STEP files is millimiters. The return object is a TopoDS_Shape which contains all objects from the file. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00244">244</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a42404c99252b6da0977f40a4eccf05d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42404c99252b6da0977f40a4eccf05d9">&#9670;&nbsp;</a></span>write_STEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::write_STEP </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given topological shape into an STEP file. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00275">275</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="aed838d4999b4707c48781b8d732058fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed838d4999b4707c48781b8d732058fe">&#9670;&nbsp;</a></span>get_shape_tolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenCASCADE::get_shape_tolerance </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the tolerance associated with the shape. Each CAD geometrical object is defined along with a tolerance, which indicates possible inaccuracy of its placement. For instance, the tolerance of a vertex indicates that it can be located in any point contained in a sphere centered in the nominal position and having radius tol. While carrying out an operation such as projecting a point onto a surface (which will in turn have its tolerance) we must keep in mind that the precision of the projection will be limited by the tolerance with which the surface is built. The tolerance is computed taking the maximum tolerance among the subshapes composing the shape. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00289">289</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ad7143020c8f7d45356e6fe0b347f73d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7143020c8f7d45356e6fe0b347f73d7">&#9670;&nbsp;</a></span>intersect_plane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Shape OpenCASCADE::intersect_plane </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>c_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>c_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>c_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the intersection of the given topological shape with the plane <img class="formulaInl" alt="$c_x x + c_y y + c_z z +c = 0$" src="form_1304.png"/>. The returned topological shape will contain as few bsplines as possible. An exception is thrown if the intersection produces an empty shape. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00315">315</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a59c5d614d74c4091fe75f61de5242b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c5d614d74c4091fe75f61de5242b0a">&#9670;&nbsp;</a></span>join_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Edge OpenCASCADE::join_edges </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to join all edges contained in the given TopoDS_Shape into a single TopoDS_Edge, containing as few BSPlines as possible. If the input shape contains faces, they will be ignored by this function. If the contained edges cannot be joined into a single one, i.e., they form disconnected curves, an exception will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00328">328</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a6754fbb50a3b0403ec30ac8d955c0cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6754fbb50a3b0403ec30ac8d955c0cee">&#9670;&nbsp;</a></span>interpolation_curve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Edge OpenCASCADE::interpolation_curve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>curve_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em> = <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,3&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>closed</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a 3D smooth BSpline curve passing through the points in the assigned vector, and store it in the returned TopoDS_Shape (which is of type TopoDS_Edge). The points are reordered internally according to their scalar product with the direction, if direction is different from zero, otherwise they are used as passed. Notice that this function changes the input points if required by the algorithm.</p>
<p>This class is used to interpolate a BsplineCurve passing through an array of points, with a C2 Continuity. If the optional parameter <code>closed</code> is set to true, then the curve will be C2 at all points except the first (where only C1 continuity will be given), and it will be a closed curve.</p>
<p>The curve is garanteed to be at distance <code>tolerance</code> from the input points. If the algorithm fails in generating such a curve, an exception is thrown. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00432">432</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a54d463f21e1fedb10a8c64eb9aefe2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d463f21e1fedb10a8c64eb9aefe2e6">&#9670;&nbsp;</a></span>extract_geometrical_shapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::extract_geometrical_shapes </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Face &gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Edge &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Vertex &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract all subshapes from a TopoDS_Shape, and store the results into standard containers. If the shape does not contain a certain type of shape, the respective container will be empty. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00109">109</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a7320b961707ca97cef441b2e8a296cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7320b961707ca97cef441b2e8a296cd8">&#9670;&nbsp;</a></span>create_triangulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Face &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a triangulation from a single face. This class extract the first u and v parameter of the parametric surface making up this face, and creates a Triangulation&lt;2,3&gt; containing a single coarse cell reflecting this face. If the surface is not a trimmed surface, the vertices of this cell will coincide with the TopoDS_Vertex vertices of the original TopoDS_Face. This, however, is often not the case, and the user should be careful on how this mesh is used. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00640">640</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a1e49f50433c835c841eed35f40862560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e49f50433c835c841eed35f40862560">&#9670;&nbsp;</a></span>extract_compound_shapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::extract_compound_shapes </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Compound &gt; &amp;&#160;</td>
          <td class="paramname"><em>compounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_CompSolid &gt; &amp;&#160;</td>
          <td class="paramname"><em>compsolids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Solid &gt; &amp;&#160;</td>
          <td class="paramname"><em>solids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Shell &gt; &amp;&#160;</td>
          <td class="paramname"><em>shells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Wire &gt; &amp;&#160;</td>
          <td class="paramname"><em>wires</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract all compound shapes from a TopoDS_Shape, and store the results into standard containers. If the shape does not contain a certain type of compound, the respective container will be empty. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00134">134</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="adcce32ffcfc85a9a90be263090cb8cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcce32ffcfc85a9a90be263090cb8cc5">&#9670;&nbsp;</a></span>project_point_and_pull_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, TopoDS_Shape, double, double &gt; OpenCASCADE::project_point_and_pull_back </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Project the point <code>origin</code> on the topological shape given by <code>in_shape</code>, and returns the projected point, the subshape which contains the point and the parametric u and v coordinates of the point within the resulting shape. If the shape is not elementary, all its subshapes are iterated, faces first, then edges, and the returned shape is the closest one to the point <code>origin</code>. If the returned shape is an edge, then only the u coordinate is filled with sensible information, and the v coordinate is set to zero.</p>
<p>This function returns a tuple containing the projected point, the shape, the u coordinate and the v coordinate (which is different from zero only if the resulting shape is a face). </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00464">464</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="af5c61bfdfb96cf38bc2dadf77184ae84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c61bfdfb96cf38bc2dadf77184ae84">&#9670;&nbsp;</a></span>closest_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; OpenCASCADE::closest_point </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the projection of the point <code>origin</code> on the topological shape given by <code>in_shape</code>. If the shape is not elementary, all its subshapes are iterated, faces first, then edges, and the returned point is the closest one to the <code>in_shape</code>, regardless of its type. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00544">544</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a9c5bed4afc0363cc8f199f7bf9be4ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5bed4afc0363cc8f199f7bf9be4ef0">&#9670;&nbsp;</a></span>push_forward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; OpenCASCADE::push_forward </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an elementary shape <code>in_shape</code> and the reference coordinates within the shape, returns the corresponding point in real space. If the shape is a TopoDS_Edge, the <code>v</code> coordinate is ignored. Only edges or faces, as returned by the function <a class="el" href="namespaceOpenCASCADE.html#adcce32ffcfc85a9a90be263090cb8cc5">project_point_and_pull_back()</a>, can be used as input to this function. If this is not the case, an Exception is thrown. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00586">586</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a17c7b59ea0d1fee16c815c7e40237aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c7b59ea0d1fee16c815c7e40237aa5">&#9670;&nbsp;</a></span>push_forward_and_differential_forms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;, double, double &gt; OpenCASCADE::push_forward_and_differential_forms </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Face &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a TopoDS_Face <code>face</code> and the reference coordinates within this face, returns the corresponding point in real space, the normal to the surface at that point and the min and max curvatures as a tuple. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00609">609</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a476712b60ff6cb2ad783f34552ef9843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476712b60ff6cb2ad783f34552ef9843">&#9670;&nbsp;</a></span>closest_point_and_differential_forms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;, double, double &gt; OpenCASCADE::closest_point_and_differential_forms </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the closest point to the given topological shape, together with the normal and the min and max curvatures at that point. If the shape is not elementary, all its sub-faces (only the faces) are iterated, faces first, and only the closest point is returned. This function will throw an exception if the <code>in_shape</code> does not contain at least one face. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00554">554</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a2db646eb968d930b5c8bb48bbbc017d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db646eb968d930b5c8bb48bbbc017d8">&#9670;&nbsp;</a></span>line_intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; OpenCASCADE::line_intersection </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intersect a line passing through the given <code>origin</code> point along <code>direction</code> and the given topological shape. If there is more than one intersection, it will return the closest one.</p>
<p>The optional <code>tolerance</code> parameter is used to compute distances. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00392">392</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a7e8e544997e65b29b37a43e82e2afcbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8e544997e65b29b37a43e82e2afcbc">&#9670;&nbsp;</a></span>point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; OpenCASCADE::point </td>
          <td>(</td>
          <td class="paramtype">const gp_Pnt &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> point into a <a class="el" href="classPoint.html">Point&lt;3&gt;</a>. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00176">176</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ab8b475d2ee9eab9aec6f229aafac30ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b475d2ee9eab9aec6f229aafac30ba">&#9670;&nbsp;</a></span>point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gp_Pnt OpenCASCADE::point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert <a class="el" href="classPoint.html">Point&lt;3&gt;</a> into <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> point. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00170">170</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="adb3e38a559f88341a8dbf835982fe085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3e38a559f88341a8dbf835982fe085">&#9670;&nbsp;</a></span>point_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenCASCADE::point_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em> = <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,3&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort two points according to their scalar product with direction. If the norm of the direction is zero, then use lexicographical ordering. The optional parameter is used as a relative tolerance when comparing objects. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00181">181</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
