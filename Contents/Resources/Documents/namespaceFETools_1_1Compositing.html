<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FETools::Compositing Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceFETools.html">FETools</a></li><li class="navelem"><a class="el" href="namespaceFETools_1_1Compositing.html">Compositing</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FETools::Compositing Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af0ac6442561c020e2096dd1893463eca"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af0ac6442561c020e2096dd1893463eca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#af0ac6442561c020e2096dd1893463eca">multiply_dof_numbers</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;fes, const std::vector&lt; unsigned int &gt; &amp;multiplicities, const bool do_tensor_product=true)</td></tr>
<tr class="separator:af0ac6442561c020e2096dd1893463eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c145f88cfc1ff2b139f1793b89f023"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae4c145f88cfc1ff2b139f1793b89f023"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#ae4c145f88cfc1ff2b139f1793b89f023">multiply_dof_numbers</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe1, const unsigned int N1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe2=nullptr, const unsigned int N2=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe3=nullptr, const unsigned int N3=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe4=nullptr, const unsigned int N4=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe5=nullptr, const unsigned int N5=0)</td></tr>
<tr class="separator:ae4c145f88cfc1ff2b139f1793b89f023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b693d8cb33a61c82cd2ef9e39b399b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa2b693d8cb33a61c82cd2ef9e39b399b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#aa2b693d8cb33a61c82cd2ef9e39b399b">compute_restriction_is_additive_flags</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;fes, const std::vector&lt; unsigned int &gt; &amp;multiplicities)</td></tr>
<tr class="separator:aa2b693d8cb33a61c82cd2ef9e39b399b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfbda8143ee7cc43d7427a25cd5fed1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8cfbda8143ee7cc43d7427a25cd5fed1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#a8cfbda8143ee7cc43d7427a25cd5fed1">compute_restriction_is_additive_flags</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe1, const unsigned int N1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe2=nullptr, const unsigned int N2=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe3=nullptr, const unsigned int N3=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe4=nullptr, const unsigned int N4=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe5=nullptr, const unsigned int N5=0)</td></tr>
<tr class="separator:a8cfbda8143ee7cc43d7427a25cd5fed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e4ec24ef54357523b966f3490e43e3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a48e4ec24ef54357523b966f3490e43e3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#a48e4ec24ef54357523b966f3490e43e3">compute_nonzero_components</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;fes, const std::vector&lt; unsigned int &gt; &amp;multiplicities, const bool do_tensor_product=true)</td></tr>
<tr class="separator:a48e4ec24ef54357523b966f3490e43e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab130b73d1aa4f570063c4f2903567b00"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab130b73d1aa4f570063c4f2903567b00"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#ab130b73d1aa4f570063c4f2903567b00">compute_nonzero_components</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe1, const unsigned int N1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe2=nullptr, const unsigned int N2=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe3=nullptr, const unsigned int N3=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe4=nullptr, const unsigned int N4=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe5=nullptr, const unsigned int N5=0, const bool do_tensor_product=true)</td></tr>
<tr class="separator:ab130b73d1aa4f570063c4f2903567b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fcbab2bc710a68602e7b34bf01396b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad2fcbab2bc710a68602e7b34bf01396b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#ad2fcbab2bc710a68602e7b34bf01396b">build_cell_tables</a> (std::vector&lt; std::pair&lt; std::pair&lt; unsigned int, unsigned int &gt;, unsigned int &gt; &gt; &amp;system_to_base_table, std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt; &amp;system_to_component_table, std::vector&lt; std::pair&lt; std::pair&lt; unsigned int, unsigned int &gt;, unsigned int &gt; &gt; &amp;component_to_base_table, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;finite_element, const bool do_tensor_product=true)</td></tr>
<tr class="separator:ad2fcbab2bc710a68602e7b34bf01396b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586ee51954a423e8a595822790e28d57"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a586ee51954a423e8a595822790e28d57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#a586ee51954a423e8a595822790e28d57">build_face_tables</a> (std::vector&lt; std::pair&lt; std::pair&lt; unsigned int, unsigned int &gt;, unsigned int &gt; &gt; &amp;face_system_to_base_table, std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt; &amp;face_system_to_component_table, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;finite_element, const bool do_tensor_product=true)</td></tr>
<tr class="separator:a586ee51954a423e8a595822790e28d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A namespace that contains functions that help setting up internal data structures when implementing <a class="el" href="classFiniteElement.html">FiniteElement</a> which are build from simpler ("base") elements, for example <a class="el" href="classFESystem.html">FESystem</a>. The things computed by these functions typically serve as constructor arguments to the <a class="el" href="classFiniteElement.html">FiniteElement</a> base class of the derived finite element object being constructed.</p>
<p>There are generally two ways in which one can build more complex elements, and this is reflected by several of the functions in this namespace having arguments called <code>do_tensor_product</code>:</p>
<ol>
<li>
<p class="startli"><a class="el" href="classTensor.html">Tensor</a> product construction (<code>do_tensor_product=true</code>): The tensor product construction, in the simplest case, builds a vector-valued element from scalar elements (see <a class="el" href="group__vector__valued.html">this documentation module</a> and <a class="el" href="DEALGlossary.html#GlossComponent">this glossary entry</a> for more information). To give an example, consider creating a vector-valued element with two vector components, where the first should have linear shape functions and the second quadratic shape functions. In 1d, the shape functions (on the reference cell) of the base elements are then </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} Q_1 &amp;= \{ 1-x, x \}, \\ Q_2 &amp;= \{ 2(\frac 12 - x)(1-x), 2(x - \frac 12)x, 4x(1-x) \}, \end{align*}" src="form_723.png"/>
</p>
<p> where shape functions are ordered in the usual way (first on the first vertex, then on the second vertex, then in the interior of the cell). The tensor product construction will create an element with the following shape functions: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} Q_1 \times Q_2 &amp;= \left\{ \begin{pmatrix} 1-x \\ 0 \end{pmatrix}, \begin{pmatrix} 0 \\ 2(\frac 12 - x)(1-x) \end{pmatrix}, \begin{pmatrix} x \\ 0 \end{pmatrix}, \begin{pmatrix} 0 \\ 2(x - \frac 12)x \end{pmatrix}, \begin{pmatrix} 0 \\ 4x(1-x) \end{pmatrix} \right\}. \end{align*}" src="form_724.png"/>
</p>
<p> The list here is again in standard order.</p>
<p>Of course, the procedure also works if the base elements are already vector valued themselves: in that case, the composed element simply has as many vector components as the base elements taken together.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Combining shape functions (<code>do_tensor_product=false</code>): In contrast to the previous strategy, combining shape functions simply takes <em>all</em> of the shape functions together. In the case above, this would yield the following element: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} Q_1 + Q_2 &amp;= \{ 1-x, 2(\frac 12 - x)(1-x), x, 2(x - \frac 12)x, 4x(1-x) \}. \end{align*}" src="form_725.png"/>
</p>
<p> In other words, if the base elements are scalar, the resulting element will also be. In general, the base elements all will have to have the same number of vector components.</p>
<p>The element constructed above of course no longer has a linearly independent set of shape functions. As a consequence, any matrix one creates by treating all shape functions of the composed element in the same way will be singular. In practice, this strategy is therefore typically used in situations where one explicitly makes sure that certain shape functions are treated differently (e.g., by multiplying them with weight functions), or in cases where the shape functions one combines are not linearly dependent.</p>
<p class="endli"></p>
</li>
</ol>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af0ac6442561c020e2096dd1893463eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ac6442561c020e2096dd1893463eca">&#9670;&nbsp;</a></span>multiply_dof_numbers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; FETools::Compositing::multiply_dof_numbers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>do_tensor_product</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take vectors of finite elements and multiplicities and multiply out how many degrees of freedom the composed element has per vertex, line, etc.</p>
<p>If <code>do_tensor_product</code> is true, the number of components returned in the <a class="el" href="classFiniteElementData.html">FiniteElementData</a> object is the sum over the product of the number of components in each of the finite elements times the corresponding multiplicity. Otherwise the number of components is taken from the first finite element with non-zero multiplicity, and all other elements with non-zero multiplicities need to have the same number of vector components.</p>
<p>See the documentation of namespace <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a> for more information about the <code>do_tensor_product</code> argument. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l00073">73</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="ae4c145f88cfc1ff2b139f1793b89f023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c145f88cfc1ff2b139f1793b89f023">&#9670;&nbsp;</a></span>multiply_dof_numbers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; FETools::Compositing::multiply_dof_numbers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>N2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>N3</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe4</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>N4</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe5</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>N5</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but for a specific number of sub-elements. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l00158">158</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="aa2b693d8cb33a61c82cd2ef9e39b399b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b693d8cb33a61c82cd2ef9e39b399b">&#9670;&nbsp;</a></span>compute_restriction_is_additive_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; FETools::Compositing::compute_restriction_is_additive_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the "restriction is additive" flags (see the documentation of the <a class="el" href="classFiniteElement.html">FiniteElement</a> class) for a list of finite elements with multiplicities given in the second argument.</p>
<p>The "restriction is additive" flags are properties of individual shape functions that do not depend on whether the composed element uses the tensor product or combination strategy outlined in the documentation of the FETools::Composition namespace. Consequently, this function does not have a <code>do_tensor_product</code> argument. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l00189">189</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="a8cfbda8143ee7cc43d7427a25cd5fed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfbda8143ee7cc43d7427a25cd5fed1">&#9670;&nbsp;</a></span>compute_restriction_is_additive_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; FETools::Compositing::compute_restriction_is_additive_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>N2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>N3</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe4</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>N4</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe5</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>N5</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> object and return a boolean vector describing the <code>restriction_is_additive_flags</code> (see the documentation of the <a class="el" href="classFiniteElement.html">FiniteElement</a> class) for each shape function of the mixed element consisting of <code>N1</code>, <code>N2</code>, ... copies of the sub-elements <code>fe1</code>, <code>fe2</code>, ...</p>
<p>The "restriction is additive" flags are properties of individual shape functions that do not depend on whether the composed element uses the tensor product or combination strategy outlined in the documentation of the FETools::Composition namespace. Consequently, this function does not have a <code>do_tensor_product</code> argument.</p>
<p>Take a <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> object and return an boolean vector including the <code>restriction_is_additive_flags</code> of the mixed element consisting of <code>N</code> elements of the sub-element <code>fe</code>. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l00316">316</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="a48e4ec24ef54357523b966f3490e43e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e4ec24ef54357523b966f3490e43e3">&#9670;&nbsp;</a></span>compute_nonzero_components() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; FETools::Compositing::compute_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>do_tensor_product</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the nonzero components for each shape function of a composed finite element described by a list of finite elements with multiplicities given in the second argument.</p>
<p>If <code>do_tensor_product</code> is true, the number of components (and thus the size of the <a class="el" href="classComponentMask.html">ComponentMask</a> objects) is the sum over the product of the number of components in each of the finite elements times the corresponding multiplicity. Otherwise the number of components is taken from the first finite element with non-zero multiplicity, and all other elements with non-zero multiplicities need to have the same number of vector components.</p>
<p>See the documentation of namespace <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a> for more information about the <code>do_tensor_product</code> argument. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l00351">351</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="ab130b73d1aa4f570063c4f2903567b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab130b73d1aa4f570063c4f2903567b00">&#9670;&nbsp;</a></span>compute_nonzero_components() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; FETools::Compositing::compute_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>N2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>N3</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe4</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>N4</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe5</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>N5</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>do_tensor_product</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the non-zero vector components of a composed finite element. This function is similar to the previous one, except that the pointers indicate the elements to be composed, and the arguments <code>N1</code>, <code>N2</code>, ... the multiplicities. Null pointers indicate that an argument is to be skipped.</p>
<p>If <code>do_tensor_product</code> is true, the number of components (and thus the size of the <a class="el" href="classComponentMask.html">ComponentMask</a> objects) is the sum over the product of the number of components in each of the finite elements times the corresponding multiplicity. Otherwise the number of components is taken from the first finite element with non-zero multiplicity, and all other elements with non-zero multiplicities need to have the same number of vector components.</p>
<p>See the documentation of namespace <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a> for more information about the <code>do_tensor_product</code> argument.</p>
<p>Compute the non-zero vector components of a composed finite element. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l00543">543</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="ad2fcbab2bc710a68602e7b34bf01396b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fcbab2bc710a68602e7b34bf01396b">&#9670;&nbsp;</a></span>build_cell_tables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::Compositing::build_cell_tables </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::pair&lt; unsigned int, unsigned int &gt;, unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>system_to_base_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>system_to_component_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::pair&lt; unsigned int, unsigned int &gt;, unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_to_base_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>finite_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>do_tensor_product</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given (composite) <code>finite_element</code> build <code>system_to_component_table</code>, <code>system_to_base_table</code> and <code>component_to_base_table</code>.</p>
<p>If <code>do_tensor_product</code> is true, the number of components used for the composite element is the sum over the product of the number of components in each of the finite elements times the corresponding multiplicity. Otherwise the number of components is taken from the first finite element with non-zero multiplicity, and all other elements with non-zero multiplicities need to have the same number of vector components.</p>
<p>See the documentation of namespace <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a> for more information about the <code>do_tensor_product</code> argument. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l00581">581</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
<a id="a586ee51954a423e8a595822790e28d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586ee51954a423e8a595822790e28d57">&#9670;&nbsp;</a></span>build_face_tables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::Compositing::build_face_tables </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::pair&lt; unsigned int, unsigned int &gt;, unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_system_to_base_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_system_to_component_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>finite_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>do_tensor_product</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given (composite) <code>finite_element</code> build <code>face_system_to_base_table</code>, and <code>face_system_to_component_table</code>.</p>
<p>If <code>do_tensor_product</code> is true, the number of components used for the composite element is the sum over the product of the number of components in each of the finite elements times the corresponding multiplicity. Otherwise the number of components is taken from the first finite element with non-zero multiplicity, and all other elements with non-zero multiplicities need to have the same number of vector components.</p>
<p>See the documentation of namespace <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a> for more information about the <code>do_tensor_product</code> argument. </p>

<p class="definition">Definition at line <a class="el" href="fe__tools_8cc_source.html#l00776">776</a> of file <a class="el" href="fe__tools_8cc_source.html">fe_tools.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
