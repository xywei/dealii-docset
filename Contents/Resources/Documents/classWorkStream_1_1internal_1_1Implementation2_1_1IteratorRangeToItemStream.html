<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: WorkStream::internal::Implementation2::IteratorRangeToItemStream&lt; Iterator, ScratchData, CopyData &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceWorkStream.html">WorkStream</a></li><li class="navelem"><b>internal</b></li><li class="navelem"><a class="el" href="namespaceWorkStream_1_1internal_1_1Implementation2.html">Implementation2</a></li><li class="navelem"><a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">IteratorRangeToItemStream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">WorkStream::internal::Implementation2::IteratorRangeToItemStream&lt; Iterator, ScratchData, CopyData &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="work__stream_8h_source.html">deal.II/base/work_stream.h</a>&gt;</code></p>

<p>Inherits filter.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html">ItemType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ada112b8790d8e429cd430e12d93a3c61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html#ada112b8790d8e429cd430e12d93a3c61">IteratorRangeToItemStream</a> (const Iterator &amp;begin, const Iterator &amp;end, const unsigned int buffer_size, const unsigned int <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html#aa44a27e01dacdd790871ba592713d403">chunk_size</a>, const ScratchData &amp;<a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html#a28e818ecdb28c89dbfcd0e89f2e18480">sample_scratch_data</a>, const CopyData &amp;sample_copy_data)</td></tr>
<tr class="separator:ada112b8790d8e429cd430e12d93a3c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569b0c964fdeb69a3339237238411bc7"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html#a569b0c964fdeb69a3339237238411bc7">operator()</a> (void *)</td></tr>
<tr class="separator:a569b0c964fdeb69a3339237238411bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad9332a3095617008b760faa4e8a5e481"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Iterator, Iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html#ad9332a3095617008b760faa4e8a5e481">remaining_iterator_range</a></td></tr>
<tr class="separator:ad9332a3095617008b760faa4e8a5e481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c033429a8c585dd240a60e2c9bf847"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html">ItemType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html#ad1c033429a8c585dd240a60e2c9bf847">item_buffer</a></td></tr>
<tr class="separator:ad1c033429a8c585dd240a60e2c9bf847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabcb6f9cbbe1b7e4b6e6880c94add66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; typename <a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html#a2fdcc0eacda3b01a499e19a053b56b7b">ItemType::ScratchDataList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html#afabcb6f9cbbe1b7e4b6e6880c94add66">thread_local_scratch</a></td></tr>
<tr class="separator:afabcb6f9cbbe1b7e4b6e6880c94add66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e818ecdb28c89dbfcd0e89f2e18480"><td class="memItemLeft" align="right" valign="top">const ScratchData &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html#a28e818ecdb28c89dbfcd0e89f2e18480">sample_scratch_data</a></td></tr>
<tr class="separator:a28e818ecdb28c89dbfcd0e89f2e18480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44a27e01dacdd790871ba592713d403"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html#aa44a27e01dacdd790871ba592713d403">chunk_size</a></td></tr>
<tr class="separator:aa44a27e01dacdd790871ba592713d403"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Iterator, typename ScratchData, typename CopyData&gt;<br />
class WorkStream::internal::Implementation2::IteratorRangeToItemStream&lt; Iterator, ScratchData, CopyData &gt;</h3>

<p>A class that creates a sequence of items from a range of iterators. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00178">178</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ada112b8790d8e429cd430e12d93a3c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada112b8790d8e429cd430e12d93a3c61">&#9670;&nbsp;</a></span>IteratorRangeToItemStream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename ScratchData, typename CopyData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">WorkStream::internal::Implementation2::IteratorRangeToItemStream</a>&lt; Iterator, ScratchData, CopyData &gt;::<a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">IteratorRangeToItemStream</a> </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>chunk_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Take an iterator range, the size of a buffer that can hold items, and the sample additional data object that will be passed to each worker and copier function invocation. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00321">321</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a569b0c964fdeb69a3339237238411bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569b0c964fdeb69a3339237238411bc7">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename ScratchData, typename CopyData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">WorkStream::internal::Implementation2::IteratorRangeToItemStream</a>&lt; Iterator, ScratchData, CopyData &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an item and return a pointer to it. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00354">354</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad9332a3095617008b760faa4e8a5e481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9332a3095617008b760faa4e8a5e481">&#9670;&nbsp;</a></span>remaining_iterator_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename ScratchData, typename CopyData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;Iterator,Iterator&gt; <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">WorkStream::internal::Implementation2::IteratorRangeToItemStream</a>&lt; Iterator, ScratchData, CopyData &gt;::remaining_iterator_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The interval of iterators still to be worked on. This range will shrink over time. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00409">409</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="ad1c033429a8c585dd240a60e2c9bf847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c033429a8c585dd240a60e2c9bf847">&#9670;&nbsp;</a></span>item_buffer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename ScratchData, typename CopyData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html">ItemType</a>&gt; <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">WorkStream::internal::Implementation2::IteratorRangeToItemStream</a>&lt; Iterator, ScratchData, CopyData &gt;::item_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A buffer that will store items. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00414">414</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="afabcb6f9cbbe1b7e4b6e6880c94add66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabcb6f9cbbe1b7e4b6e6880c94add66">&#9670;&nbsp;</a></span>thread_local_scratch</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename ScratchData, typename CopyData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt;typename <a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html#a2fdcc0eacda3b01a499e19a053b56b7b">ItemType::ScratchDataList</a>&gt; <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">WorkStream::internal::Implementation2::IteratorRangeToItemStream</a>&lt; Iterator, ScratchData, CopyData &gt;::thread_local_scratch</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to a thread local variable identifying the scratch data objects this thread will use. The initial implementation of this class using thread local variables provided only a single scratch object per thread. This doesn't work, because the worker functions may start tasks itself and then call <a class="el" href="classThreads_1_1TaskGroup.html#a2917c607a567538f8e560c849fa88ac6">Threads::TaskGroup::join_all()</a> or a similar function, which the TBB scheduler may use to run something else on the current thread &ndash; for example another instance of the worker function. Consequently, there would be two instances of the worker function that use the same scratch object if we only provided a single scratch object per thread. The solution is to provide a list of scratch objects for each thread, together with a flag indicating whether this scratch object is currently used. If a thread needs a scratch object, it walks this list until it finds an unused object, or, if there is none, creates one itself. Note that we need not use synchronization primitives for this process since the lists are thread-local and we are guaranteed that only a single thread accesses them as long as we have no yield point in between the accesses to the list.</p>
<p>The pointers to scratch objects stored in each of these lists must be so that they are deleted on all threads when the thread local object is destroyed. This is achieved by using shared_ptr.</p>
<p>Note that when a worker needs to create a scratch object, it allocates it using sample_scratch_data to copy from. This has the advantage of a first-touch initialization, i.e., the memory for the scratch data object is allocated and initialized by the same thread that will later use it. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00446">446</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="a28e818ecdb28c89dbfcd0e89f2e18480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e818ecdb28c89dbfcd0e89f2e18480">&#9670;&nbsp;</a></span>sample_scratch_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename ScratchData, typename CopyData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ScratchData&amp; <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">WorkStream::internal::Implementation2::IteratorRangeToItemStream</a>&lt; Iterator, ScratchData, CopyData &gt;::sample_scratch_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A reference to a sample scratch data that will be used to initialize the thread-local pointers to a scratch data object each of the worker tasks uses. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00453">453</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="aa44a27e01dacdd790871ba592713d403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44a27e01dacdd790871ba592713d403">&#9670;&nbsp;</a></span>chunk_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename ScratchData, typename CopyData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">WorkStream::internal::Implementation2::IteratorRangeToItemStream</a>&lt; Iterator, ScratchData, CopyData &gt;::chunk_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of elements of the iterator range that each thread should work on sequentially; a large number makes sure that each thread gets a significant amount of work before the next task switch happens, whereas a small number is better for load balancing. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00461">461</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>deal.II/base/<a class="el" href="work__stream_8h_source.html">work_stream.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
